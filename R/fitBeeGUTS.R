#' Fit a GUTS model for bees survival analysis using Bayesian Inference (stan)
#'
#' @description The function \code{fitBeeGUTS} estimates the parameters of a GUTS model
#' for the stochastic death (SD) or individual tolerance (IT) death mechanisms for
#' survival analysis using Bayesian inference.
#'
#' @param data An object of class \code{beeSurvData}
#' @param modelType A model type between \code{"SD"} for Stochastic Death and
#' \code{"IT"} for Individual Tolerance.
#' @param distribution A distribution for the IT death mechanism. To be chosen between
#' \code{"loglogistic"} and \code{"lognormal"}. Default is \code{"loglogistic"}
#' @param priorsList A list containing the prior distribution for the parameter considered.
#' By default, when no priors are provided (default is \code{NULL}), priors are set automatically
#' based on the experimental design (adapted from Delignette-Muller et al 2017)
#' @param parallel Logical indicating whether parallel computing should be used or not.  Default is \code{TRUE}
#' @param nCores A positive integer specifying the number of cores to use.
#' Default is one core less than maximum number of cores available
#' @param nChains A positive integer specifying the number of MCMC chains to run. Default is 3.
#' @param nIter A positive integer specifying the number of iteration to monitor for each MCMC chain. Default is 2000
#' @param nWarmup A positive integer specifying the number of warmup iteration per chain. Default is half the number of iteration
#' @param thin A positive integer specifying the interval between the iterations to monitor. Default is 1 (all iterations are monitored)
#' @param adaptDelta A double, bounded between 0 and 1 and controlling part of the sampling algorithms.
#' See the \code{control} in the function \code{stan} [rstan::stan()] of the package \code{rstan}. The default is 0.95.
#' @param odeIntegrator A string specifying the integrator used to solve the system of
#' differential equations (ODE) in the \code{stan} module. To be chosen between
#' \code{"rk45"} and \code{"bdf"}. Default is \code{"rk45"}.
#' @param relTol A double, bounded between 0 and 1 and controlling the relative tolerance
#' of the accuracy of the solutions generated by the integrator. A smaller tolerance produces
#' more accurate solution at the expanse of the computing time. Default is 1e-8
#' @param absTol A double, bounded between 0 and 1 and controlling the absolute tolerance
#' of the accuracy of the solutions generated by the integrator. A smaller tolerance produces
#' more accurate solution at the expanse of the computing time. Default is 1e-8
#' @param maxSteps A double controlling the maximum number of steps that can be
#' taken before stopping a runaway simulation. Default is 1000
#' @param ... Additional parameters to be passed to \code{sampling} from \code{stan}
#'
#' @details The automated prior determination is modified from Delignette-Muller et al.
#' by considering that the minimal concentration for the prior can be close to 0 (1e-6)
#' whereas the original paper considered the lowest non-zero concentration.
#' Similarly, the minimal kd considered for the prior calculation was reduced to allow
#' more chance to capture slow kinetics.
#'
#' @return The function \code{fitBeeGUTS} returns the parameter estimates
#' of the General Unified Threshold model of Survival (GUTS) in an object
#' of class \code{beeSurvFit}. This object is a list composed of the following:
#' \item{stanFit}{An object of S4 class \code{stanfit}. More information is available
#' in the package \code{rstan}. }
#' \item{data}{The data object provided as argument of the function}
#' \item{dataFit}{A list of data passed to the Stan model object}
#' \item{setupMCMC}{A list containing the setup used for the MCMC chains}
#' \item{modelType}{A character vector specifying the type of GUTS model used between
#' \code{SD} and \code{IT}}
#' \item{distribution}{A character vector specifying the type of distribution used in case \code{IT} was used;
#' \code{NA} otherwise}
#' \item{messages}{A character vector containing warning messages}
#'
#' @references
#' Delignette-Muller, M.L., Ruiz P. and Veber P. (2017).
#' Robust fit of toxicokinetic-toxicodynamic models using prior knowledge contained in the design of survival toxicity tests.
#' \doi{10.1021/acs.est.6b05326}
#'
#' @export
#'
#' @examples
#' \donttest{
#' data(betacyfluthrinChronic)
#' fit <- fitBeeGUTS(betacyfluthrinChronic, modelType = "SD", nIter = 1000, nCores = 2)
#' }
fitBeeGUTS <- function(data, # CHECK CORRECT DATA OBJECT IS USED !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                       modelType = NULL,
                       prefithb = FALSE,
                       distribution = "loglogistic",
                       priorsList = NULL,
                       parallel = TRUE,
                       nCores = parallel::detectCores()-1L,
                       nChains = 3,
                       nIter = 2000,
                       nWarmup = floor(nIter / 2),
                       thin = 1,
                       adaptDelta = 0.95,
                       odeIntegrator = "rk45",
                       relTol = 1e-8,
                       absTol = 1e-8,
                       maxSteps = 1000,
                       ...) {
  # Check correct user inputs
  if (!is(data,"beeSurvData")) {
    stop("fitBeeGUTS: a 'data' object of class 'beeSurvData' is expected")
  }
  if (is.null(modelType) || !(modelType %in% c("SD", "IT"))) {
    stop("You need to specifiy a correct 'modelType' amongst 'SD' and 'IT'.
         'PROPER' is not yet implemented. When selecting 'IT' please also
         provide a 'distribution' parameter amongst 'loglogistic' and 'lognormal'.")
  }
  if (!(distribution %in% c("loglogistic", "lognormal"))) {
    stop("You need to specifiy a correct 'distribution' amongst 'loglogistic' and 'lognormal'.")
  }
  if (!(odeIntegrator %in% c("rk45"))) {
    stop("You need to specifiy a correct 'odeIntegrator' amongst 'rk45'.
         'bdf' is not yet implemented")
  }

  # Regroup control for the ode solver
  odeControl <- list(relTol = relTol, absTol = absTol, maxSteps = maxSteps)

  # Prepare data for inference with stan
  lsFullData <- dataFitStan(data, modelType, odeControl, priorsList)
  lsStanData <- lsFullData
  lsStanData$replicateConc <- NULL # NECESSARY?????????????????????????????????????????????????????????
  lsStanData$replicateNsurv <- NULL # NECESSARY?????????????????????????????????????????????????????????
  lsStanData$Ninit <- NULL # NECESSARY?????????????????????????????????????????????????????????

  if (modelType == "SD") {
    modelObject <- stanmodels$GUTS_SD
  }
  if (modelType == "IT") {
    modelObject <- stanmodels$GUTS_IT
    lsStanData$distribution <- switch(distribution, loglogistic = 1, lognormal = 2)
  }

  # Set options for parallel computing
  if (parallel == TRUE) {
    op <- options()
    options(mc.cores = as.integer(nCores))
    on.exit(options(op))

  }

  if (prefithb == TRUE){
    hbfit = fit_hb(data,...)
    hbfitsum = rstan::summary(hbfit)
    # approximate the new prior from the result with a normal distribution
    # on log scale
    # NEEDS additional testing
    lsStanData$hbMean_log10 = hbfitsum$summary["hb_log10[1]","mean"]
    lsFullData$hbMean_log10 = hbfitsum$summary["hb_log10[1]","mean"]
    lsStanData$hbSD_log10 = hbfitsum$summary["hb_log10[1]","sd"]
    lsFullData$hbSD_log10 = hbfitsum$summary["hb_log10[1]","sd"]
  }

  # Sample MCMC chains
  fit <- rstan::sampling(
    object = modelObject,
    data = lsStanData,
    chains = nChains,
    iter = nIter,
    warmup = nWarmup,
    thin = thin,
    control = list(adapt_delta = adaptDelta),
    ...)

  # cleanup parallel computing options
  if (parallel == TRUE) {
    options(op)
  }

  # Infos on MCMC chains
  setupMCMC <- data.frame(nIter = nIter,
                          nChains = nChains,
                          thinInterval = thin,
                          nWarmup = nWarmup)

  ## Warnings on fit quality

  outRhat <- rstan::summary(fit)$summary[, "Rhat"]

  if (!all(outRhat < 1.1, na.rm = TRUE)){
    msg <- "
    *** Markov chains did not converge! Do not analyze results! ***.
    Plot MCMC chains and try the following options:
    (1) if one or more chain are a simple stable line, increase 'adapt_delta' (default is 0.95).
    (2) if the variabbility between chain is great, you can increase the number of iteration (default is 2000 iteration).
    (3) if 'Conditional_Psurv_hat' is greater than 1, the ODE integration is wrong. So you can reduce the tolerance of the ODE integrator."
    warning(msg, call. = FALSE)
    print(outRhat)
  } else {
    msg <- "NA"
  }

  # Return
  lsOut <- list(stanFit = fit,
                data = data,
                dataFit = lsFullData,
                setupMCMC = setupMCMC,
                modelType = modelType,
                distribution = ifelse(modelType == "IT", distribution, "NA"),
                messages = msg)
  class(lsOut) <- "beeSurvFit"

  return(lsOut)
}



fit_hb = function(data,nChains = 3,
                  nIter = 2000,
                  nWarmup = floor(nIter / 2),
                  thinInterval = 1,
                  adaptDelta = 0.95){
  # Need here to perform a fit of the hb value for each of the calibration
  # datasets
  cat("Fitting the background mortality parameter on the control data.","\n")
  data_control = NULL
  for (i in 1:data$nDatasets){
    data_control$survData_long[[i]] = data$survData_long[[i]] %>%
      dplyr::filter(Treatment == "Control")
    data_control$concModel_long[[i]] = data$concModel_long[[i]] %>%
      dplyr::filter(Treatment == "Control")
  }
  dataSurv <- dplyr::bind_rows(data_control$concModel_long) %>%
              dplyr::filter(!is.na(Conc)) %>%
              dplyr::arrange(Dataset, Treatment, SurvivalTime) %>%
              dplyr::mutate(idAll = dplyr::row_number() ) %>%
              dplyr::filter(SurvivalTime != 0)
  timeMin = min(dataSurv$SurvivalTime)
  timeMax <- max(dataSurv$SurvivalTime)
  hbMax = -log(0.5) / timeMin
  hbMin = -log(0.999) / timeMax
  hbMean_log10 =  .priorMean(hbMin, hbMax)
  hbSD_log10 = .priorSD(hbMin, hbMax)

  priorlist = c(hbMean_log10 =  hbMean_log10,
                hbSD_log10 = hbSD_log10)
  data_control$nDatasets = data$nDatasets
  lsStanData <- dataFitStan(data_control, "SD", NULL, priorlist)
  lsStanData$nGroups = rep(1,data$nDatasets)
  lsStanData$nGroup = sum(lsStanData$nGroups)
  if (length(lsStanData$nGroups)>1){
    lsStanData$groupDataset = rep(1:length(lsStanData$nGroups), lsStanData$nGroups)
  } else {
    lsStanData$groupDataset = array(rep(1:length(lsStanData$nGroups), lsStanData$nGroups),dim = lsStanData$nGroups)
  }

  modelObject <- stanmodels$GUTS_hb_only
  chcr <- Sys.getenv("_R_CHECK_LIMIT_CORES_", "")
  if (nzchar(chcr) && chcr == "TRUE") {
    # this is needed in order to pass CRAN checks
    # use 2 cores in CRAN/Travis/AppVeyor
    nCores <- 2L
  } else {
    # use all cores in devtools::test()
    nCores = parallel::detectCores(logical = FALSE)-1L
  }
  op <- options()
  options(mc.cores = as.integer(nCores))
  on.exit(options(op))

  hbfit <- rstan::sampling(
    object = modelObject,
    data = lsStanData,
    chains = nChains,
    iter = nIter,
    warmup = nWarmup,
    thin = thinInterval,
    control = list(adapt_delta = 0.95))

  tmpRes <- rstan::monitor(hbfit, print = FALSE)
  maxRhat <- max(rstan::summary(hbfit)$summary[,"Rhat"], na.rm= TRUE)
  minBulk_ESS <- min(tmpRes$Bulk_ESS)
  minTail_ESS <- min(tmpRes$Tail_ESS)

  ## Common parameters
  hb_med <- c()
  hb_inf95 <- c()
  hb_sup95 <- c()
  for(i in 1:data$nDatasets){
    parname <- ifelse(data$nDatasets == 1, "hb_log10", paste0("hb_log10[",i,"]"))
    hb_med[i] <- 10^tmpRes[[parname, "50%"]]
    hb_inf95[i] <- 10^tmpRes[[parname, "2.5%"]]
    hb_sup95[i] <- 10^tmpRes[[parname, "97.5%"]]
  }
  hbNames <- c()
  for(i in 1:data$nDatasets){
    hbNames[i] <- paste0("hb[",i,"]")
  }
  outPost_hb <- data.frame(parameters = hbNames,
                           median = hb_med,
                           Q2.5 = hb_inf95,
                           Q97.5 = hb_sup95)

  cat("Bayesian Inference performed with Stan.\n",
      "MCMC sampling setup (select with '$setupMCMC')\n",
      "Iterations:", nIter, "\n",
      "Warmup iterations:", nWarmup, "\n",
      "Thinning interval:", thinInterval, "\n",
      "Number of chains:", nChains,"\n")
  cat("\nMaximum Rhat computed (na.rm = TRUE):", maxRhat, "\n",
      "Minimum Bulk_ESS:", minBulk_ESS, "\n",
      "Minimum Tail_ESS:", minTail_ESS, "\n",
      "Bulk_ESS and Tail_ESS are crude measures of effecting sampling size for
      bulk and tail quantities respectively. An ESS > 100 per chain can be
      considered as a good indicator. Rhat is an indicator of chains convergence.
      A Rhat <= 1.05 is a good indicator of convergence. For detail results,
      one can call 'rstan::monitor(beeSurvValidation$hbfit)","\n\n")

  cat("Results for hb:","\n")
  print(outPost_hb, row.names = FALSE)

  return(hbfit)
}


# internal --------------------------------------------------------------------

# Compute priors Mean and SD for lognormal distribution

.priorMean <- function(xMin, xMax){
  (log10(xMax) + log10(xMin)) / 2
}

.priorSD <- function(xMin, xMax){
  (log10(xMax) - log10(xMin)) / 4
}
